% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runABM.R
\name{runABM}
\alias{runABM}
\title{Run the ABM simulation}
\usage{
runABM(
  G,
  plan = NULL,
  update_FUN_name = NULL,
  stop_FUN_name = NULL,
  times = 1,
  save_log = TRUE,
  seed = NULL,
  add_tryCatch = TRUE,
  return_update_FUN = FALSE,
  saveRDS_inbetween = FALSE,
  temp_E = TRUE,
  RDS_file_name = "G_temp.rds"
)
}
\arguments{
\item{G}{An \code{ABM_G} object representing the simulation state and structure.}

\item{plan}{A character vector specifying the sequence of functions to execute
in each simulation step. Can include agent-level functions using the syntax \code{agent:fun(arg=val)}.
Defaults to \code{NULL}.}

\item{update_FUN_name}{A character scalar specifying the name of an \code{update_FUN}
already stored in \code{G}. If \code{NULL}, an update function is generated from \code{plan}.}

\item{stop_FUN_name}{A character scalar indicating the name of a stop function stored in \code{G}.
If \code{NULL}, the simulation stops after \code{times} steps.}

\item{times}{Integer specifying the number of steps to run the simulation
(used only if \code{stop_FUN_name} is not provided). Defaults to \code{1}.}

\item{save_log}{Logical; if \code{TRUE}, logs the state at each time step using \code{G$.save()}.
Defaults to \code{TRUE}.}

\item{seed}{Optional integer; if \code{NULL}, the seed is derived from \code{Sys.time()}.}

\item{add_tryCatch}{Logical; if \code{TRUE}, each function call is wrapped in \code{tryCatch()}
to allow simulations to continue in case of errors. Defaults to \code{TRUE}.}

\item{return_update_FUN}{Logical; if \code{TRUE}, the body of the final \code{update_FUN} is saved in
\code{G$notes$update_FUN_used}. Defaults to \code{FALSE}.}

\item{saveRDS_inbetween}{Logical; if \code{TRUE}, saves the entire \code{G} object as an RDS file
at every simulation step. Defaults to \code{FALSE}.}

\item{temp_E}{Logical; if \code{TRUE}, creates a temporary environment \code{E} passed
to each function during simulation. Defaults to \code{TRUE}.}

\item{RDS_file_name}{A character scalar specifying the file name for saving RDS
objects if \code{saveRDS_inbetween = TRUE}. Defaults to \code{"G_temp.rds"}.}
}
\value{
The updated \code{ABM_G} object after running the simulation.
If \code{return_update_FUN = TRUE}, the update function used is stored as a character
vector in \code{G$notes$update_FUN_used}.
}
\description{
Runs a simulation using an \code{ABM_G} object, either by executing a predefined update
function or by constructing an update function from a user-defined execution plan.
The simulation proceeds step by step and can include logging, custom stop conditions,
and RDS file output.
}
\details{
The simulation proceeds by either calling a registered \code{update_FUN} stored in \code{G},
or generating a new one based on a user-defined \code{plan}.
Each element of \code{plan} can be a function name (e.g., \code{"fun_name"})
or a namespaced string specifying the target agent group (e.g., \code{"agents:fun_name"}).

If multiple elements are provided in \code{plan}, they are executed sequentially
in the specified order at each time step. For example,
\code{c("children:get_older", "parents:get_older")} applies the \code{get_older}
function to both children and parents agents in order.

If no \code{select_FUN} is provided prior to an \code{act_FUN}, a default
\code{[select_all]} is automatically inserted for convenience.
When using \code{plan}, each entry can reference a global or agent-level function,
and arguments can be passed via standard R function syntax. Agent-level functions must be
preceded by a valid \code{select_FUN}, which selects the agents to which the function applies.
If no \code{select_FUN} is present, a default \code{[select_all]} is added automatically.

If \code{add_tryCatch = TRUE}, runtime errors in user-defined functions are caught
and logged as warnings, and simulation continues.

To examine the simulation runtime, the total elapsed time is printed and also saved in
\code{G$notes$simulation_took}.
}
\examples{
# Setup agents
children_attr <- data.frame(age = c(0, 1, 2))
get_older <- function() { self$age <- self$age + 1 }
children <- init_agents(attr_df = children_attr, act_FUN = get_older)

# Initialize the ABM environment
G1 <- setABM(agents = children)

# Run simulation for 5 steps using a plan
G1_out <- runABM(G = G1, plan = "get_older", times = 5)
G1_out$children

# Run simulation using a named update function
add_1_to_all_children <- function(){lapply(1:length(G$children),
function(i){G$children[[i]]$age <- G$children[[i]]$age + 1})}
G2 <- modify_G(G = G1, field_name = "add_1_to_all_children",
method = "add_update_FUN",
               new_obj = add_1_to_all_children)
G2_out <- runABM(G = G2, update_FUN_name = "add_1_to_all_children",
                 times = 5)
G2_out$children

# A plan with two act_FUN for different agents
parent_attr <- data.frame(age = c(30, 31, 32))
parents <- init_agents(attr_df = parent_attr, act_FUN = get_older)
G3 <- modify_G(G = G1, field_name = "parents",
method = "add_agents", new_obj = parents)
G3_out <- runABM(G = G3, plan = c("children:get_older", "parents:get_older"),
times = 3)
G3_out$children
G3_out$parents

}
