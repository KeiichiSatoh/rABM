% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test_FUN.R
\name{test_FUN}
\alias{test_FUN}
\title{Interactively test and refine a new function against an ABM environment}
\usage{
test_FUN(
  G,
  new_FUN_name,
  new_FUN,
  agents_name = NULL,
  agents_idx = NULL,
  FUN_type = c("act_FUN", "global_FUN", "select_FUN", "stop_FUN", "update_FUN",
    "summary_FUN", "plot_FUN"),
  with_repl = TRUE,
  print_changes = TRUE
)
}
\arguments{
\item{G}{An \code{ABM_G} object. The target ABM environment to which the new
function will be attached and tested. Must inherit from class \code{"ABM_G"}.}

\item{new_FUN_name}{A length‑1 character string. The \strong{new} field/method
name to create. Must not already exist in the target location (checked).}

\item{new_FUN}{A function object (or a list of functions if you extend this
behavior) to be attached. Its \code{G}/\code{E} formals—if present—are ignored and
replaced by internally managed ones during testing.}

\item{agents_name}{Optional character scalar. Required when
\code{FUN_type = "act_FUN"}. The name of the agent collection inside \code{G}
(e.g., \code{"children"}).}

\item{agents_idx}{Optional integer vector. Only for \code{FUN_type = "act_FUN"}.
Indices of agents within \code{G[[agents_name]]} that should receive the new
method. Defaults to \strong{all} agents in that collection. Must be within
bounds.}

\item{FUN_type}{Character scalar; one of
\code{c("act_FUN","global_FUN","select_FUN","stop_FUN","update_FUN","summary_FUN","plot_FUN")}.
Determines where and how the function is attached.}

\item{with_repl}{Logical (default \code{TRUE}). If \code{FALSE}, the function is added,
run once, and the (possibly normalized) function is returned \strong{without}
entering the interactive REPL.}

\item{print_changes}{Logical (default \code{TRUE}). If \code{TRUE}, prints the result
of \code{\link[=compare_G]{compare_G()}} after each run to highlight changes to \code{G}.}
}
\value{
A function object. Specifically, the final version of the function
(potentially edited during the REPL) with cleaned formals and environment,
suitable for saving (e.g., assigning into your package or writing to file).
Side effects occur only on \strong{cloned} \code{G} objects within the session; the
original \code{G} passed in is not mutated.
}
\description{
\code{test_FUN()} adds a \strong{new function} (agent action or global function) to an
existing ABM environment \code{G}, runs it once, \strong{diffs the changes} with
\code{\link[=compare_G]{compare_G()}}, and optionally opens an \strong{interactive REPL} to debug, edit,
re‑run, or reset the function and/or \code{G}. When you end the REPL, the function
(possibly edited during the session) is \strong{returned} as a plain function with
a cleaned environment, ready to be stored or reused.
}
\details{
The workflow is:
\enumerate{
\item Validate inputs and \strong{clone} the provided \code{G} for safety (\code{G_original}, \code{G_new}).
\item Insert \code{new_FUN} into \code{G} at the specified location depending on \code{FUN_type}.
\item \strong{Run once} and show changes with \code{\link[=compare_G]{compare_G()}} (optional).
\item If \code{with_repl = TRUE}, enter an interactive REPL that supports:
\itemize{
\item Running the function again,
\item One‑shot debugging (\code{DEBUG}) via \code{utils::debugonce()},
\item In‑place editing of the function body (\code{EDIT}) via \code{utils::edit()},
\item Resetting \code{G} or the function to original state,
\item Printing the current function, or arbitrary R evaluation.
}
}

During setup, the function’s formal arguments \code{G} and \code{E} are normalized:
user‑supplied \code{G}/\code{E} formals are temporarily removed and replaced with
internally managed \code{G} (the working clone) and \code{E} (a fresh
\code{\link[rlang:env]{rlang::new_environment()}} used as a scratch pad). The \code{E} environment is
removed on exit. The \strong{returned function} is re‑parsed to strip srcref and
injected bindings so it can be saved cleanly in user code.
}
\section{Supported locations (\code{FUN_type}) and effects}{

\describe{
\item{\code{"act_FUN"}}{Adds a method named \code{new_FUN_name} to selected agents
under \code{G[[agents_name]]}. For agents not listed in \code{agents_idx}, a dummy
placeholder is added so that the field exists on all agents.}
\item{\code{"global_FUN"}, \code{"select_FUN"}, \code{"stop_FUN"}, \code{"update_FUN"},
\code{"summary_FUN"}, \code{"plot_FUN"}}{Adds a new function field named
\code{new_FUN_name} onto \code{G} via \code{\link[=modify_G]{modify_G()}} with the corresponding
\verb{add_*_FUN} method.}
}
}

\section{REPL commands}{

\describe{
\item{\code{RUN}}{Execute the current function against the working \code{G} and print diffs (if \code{print_changes}).}
\item{\code{DEBUG}}{Debug the function once with browser commands (\code{n}, \code{s}, \code{c}, \code{where}, etc.). For \code{act_FUN}, you will be prompted for a single \code{idx}.}
\item{\code{EDIT}}{Open an editor for the function, save, and replace the version on \code{G}.}
\item{\code{RESET_G}}{Restore \code{G} to the original input (\code{G_original}) and re‑attach the current function.}
\item{\code{RESET_FUN}}{Restore the function body to the initially provided \code{new_FUN}.}
\item{\code{PRINT}}{Print the current function object.}
\item{\code{HELP}}{Show the REPL help again.}
\item{\code{END}}{Exit the REPL and return the (possibly edited) function.}
\item{Any R expression}{Evaluate in the current session (e.g., \code{G$time}).}
}
}

\section{Validation rules}{

\itemize{
\item \code{G} must inherit from \code{"ABM_G"}.
\item \code{new_FUN_name} must be a length‑1 character and must \strong{not} already exist
at the target location.
\item For \code{FUN_type = "act_FUN"}, \code{agents_name} is required and
\code{G[[agents_name]][[1]]} must inherit from \code{"ABM_Agent"}.
\item For \code{agents_idx} (when provided), indices must be numeric and within range.
}
}

\examples{
\dontrun{
# Assume you have an ABM with children agents:
children_attr <- data.frame(age = c(0, 1, 2))
get_older <- function(){ self$age <- self$age + 1 }
children <- init_agents(attr_df = children_attr, act_FUN = list(get_older = get_older))
G <- setABM(agents = children)

# Define a new action that adds 2 years:
add_two_years <- function(G, E){ self$age <- self$age + 2 }

# Interactively attach and test it on all children:
f <- test_FUN(
  G = G,
  new_FUN_name = "add_two_years",
  new_FUN = add_two_years,
  agents_name = "children",
  FUN_type = "act_FUN",
  with_repl = TRUE,
  print_changes = TRUE
)

# After the REPL ends, `f` holds the finalized function.
}

}
\seealso{
\code{\link[=compare_G]{compare_G()}}, \code{\link[=modify_G]{modify_G()}}, \code{\link[=setABM]{setABM()}}, \code{\link[=init_agents]{init_agents()}},
\code{\link[base:debug]{base::debugonce()}}, \code{\link[utils:edit]{utils::edit()}}
}
\concept{rABM developer tools}
